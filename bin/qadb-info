#!/usr/bin/env ruby

require 'json'
require 'yaml'
require 'optparse'

# get software info
TopDir  = File.realpath(File.join __dir__, '..')
QaDir   = File.realpath(File.join TopDir, 'qadb')
ExeName = File.basename __FILE__


##################################################################################
# parse options
##################################################################################

# default options
opts = {
  :print => {
    :mode        => '',
    :run_group   => nil,
    :only_latest => nil,
    :porcelain   => false,
  },
  :charge => {
    :datasets      => [],
    :runs          => [],
    :reject_defect => [],
    :allow_defect  => [],
    :reject_misc   => [],
    :allow_misc    => [],
    :verbose       => false,
    :output        => 'default',
  },
}

# helper functions
def command_banner(o, c)
  o.banner = "USAGE: #{ExeName} #{c} [OPTIONS]..."
  o.separator ''
  o.separator 'OPTIONS'
end

def on_help(o)
  o.on_tail('-h', '--help', 'show this message') do
    puts o
    exit
  end
end

# parser for the command
command_parser = OptionParser.new do |o|
  o.banner = "USAGE: #{ExeName} [COMMAND] [OPTIONS]..."
  o.separator """
  This program prints information about the QADB and its contents: QA data for
  each run as well as charge, which may be filtered by the QA. It is meant for
  single-use, that is, do not use this program in an event loop, since it is
  not designed to be efficient; instead, use the QADB Iguana algorithm for
  efficient analysis.

COMMANDS
    print      print some general information about the QADB datasets
               and defect bit definitions

    charge     get the Faraday Cup (FC) charge

  For usage guidance of each COMMAND, run with no further options (or with --help)

MISC OPTIONS"""
  o.on('-v', '--version', 'print the QADB version number') do
    ver = `cd #{TopDir} && git describe --tags --abbrev=0`
    if $?.success?
      puts ver
      exit
    else
      puts 'UNKNOWN'
      exit 1
    end
  end
  on_help o
end

# parser for the command's options
subcommand_parser = {

  'print' => OptionParser.new do |o|
    command_banner o, 'print'
    o.on('-l', '--list', 'list the available datasets') do
      opts[:print][:mode] = 'list'
    end
    o.on('-v', '--verbose', 'print verbose information about the datasets') do
      opts[:print][:mode] = 'verbose'
    end
    o.separator ''
    o.on('-d', '--defects', 'list the defects and their definitions;', 'see documentation for more info') do
      opts[:print][:mode] = 'defects'
    end
    o.separator ''
    o.separator 'FILTERING OPTIONS'
    o.on('-R', '--run-group RUN_GROUP', String, 'only include datasets for this run group') do |a|
      opts[:print][:run_group] = a
    end
    o.on('-L', '--[no-]latest', 'only list the "latest" cooks\' datasets', 'default: lists all datasets') do |a|
      opts[:print][:only_latest] = a
    end
    o.on('-P', '--[no-]porcelain', 'keep printout simple, for scripts') do |a|
      opts[:print][:porcelain] = a
    end
    o.separator ''
    o.separator 'OTHER OPTIONS'
    on_help o
  end,

  'charge' => OptionParser.new do |o|
    command_banner o, 'charge'
    o.separator """
    NOTE: all `LIST` arguments must be delimited by commas, for example:
            #{ExeName} charge --datasets rgb_sp19,rgb_fa19,rgb_wi20
    """
    o.on('-d', '--datasets LIST', Array, 'list of datasets to include', 'default: all the latest cooks\' datasets (which may be slow!)') do |a|
      opts[:charge][:datasets] = a
    end
    o.separator ''
    o.on('-r', '--runs LIST', Array, 'list of runs to include', 'default: all of them of the datasets from `--datasets`') do |a|
      opts[:charge][:runs] = a
    end
    o.separator ''
    o.on('--reject LIST', Array, 'list of defect bit numbers to reject, and allow all others;', 'do not use this together with --allow') do |a|
      opts[:charge][:reject_defect] = a.map &:to_i
    end
    o.on('--allow LIST',  Array, 'list of defect bit numbers to allow, and reject all others;', 'do not use this together with --reject') do |a|
      opts[:charge][:allow_defect] = a.map &:to_i
    end
    o.separator ''
    o.on('--reject-misc LIST', Array, 'list of runs to reject, if they have the "Misc" defect;', 'do not use this together with --allow-misc') do |a|
      opts[:charge][:reject_misc] = a.map &:to_i
    end
    o.on('--allow-misc LIST',  Array, 'list of runs to allow, if they have the "Misc" defect;', 'do not use this together with --reject-misc') do |a|
      opts[:charge][:allow_misc] = a.map &:to_i
    end
    o.separator ''
    o.on('-v', '--[no-]verbose', 'print more information') do |a|
      opts[:charge][:verbose] = a
    end
    o.separator ''
    o.separator 'OUTPUT OPTIONS'
    o.separator '''
    NOTE: unless one of the following options is used, the default output is a
          table, with values that may be rounded for readability
    '''
    o.on('--json', 'output JSON format') do |a|
      opts[:charge][:output] = 'json'
    end
    o.on('--yaml', 'output YAML format') do |a|
      opts[:charge][:output] = 'yaml'
    end
    o.on('--ttree', 'text table for ROOT\'s `TTree::ReadFile`') do |a|
      opts[:charge][:output] = 'ttree'
    end
    o.separator ''
    o.separator 'OTHER OPTIONS'
    on_help o
  end,

}

# do the parsing
command_parser.order!(ARGV.empty? ? ['--help'] : ARGV)
Command = ARGV.shift
raise "unknown command '#{Command}'; for guidance, run '#{ExeName} --help'" unless subcommand_parser.has_key? Command
subcommand_parser[Command].order!(ARGV.empty? ? ['--help'] : ARGV)

# get defect bits
defect_defs = JSON.load_file(File.join QaDir, 'defect_definitions.json')

# get datasets
dataset_hash = Hash.new
Dir.chdir(QaDir) do
  Dir.glob("**/*").each do |path|

    dataset_name = ''
    dataset_info = Hash.new

    if File.symlink?(path) and path.split('/').include?('latest')
      dataset_name = File.basename path
      next unless opts[:print][:only_latest].nil? or opts[:print][:only_latest]==true
      dataset_info = {
        :cook       => 'latest',
        :refers_to  => File.readlink(path).split('/')[1],
        :qaTree     => File.join(QaDir, path, "qaTree.json"),
        :chargeTree => File.join(QaDir, path, "chargeTree.json"),
      }

    elsif File.file?(path) and File.basename(path) == 'qaTree.json'
      dataset_name = File.dirname path
      next unless opts[:print][:only_latest].nil? or opts[:print][:only_latest]==false
      dataset_info = {
        :cook       => dataset_name.split('/').first,
        :qaTree     => File.join(QaDir, path),
        :chargeTree => File.join(QaDir, path),
      }

    else
      next
    end

    if opts[:print][:run_group].nil? or dataset_name.match?(/rg#{opts[:print][:run_group].downcase}/)
      dataset_hash[dataset_name] = dataset_info
    end

  end
end

raise "run group '#{opts[:print][:run_group]}' has no QADB available" if dataset_hash.empty?



##################################################################################
##################################################################################
# COMMAND IMPLEMENTATIONS
##################################################################################
##################################################################################

case Command

##################################################################################
# Command == 'print'
##################################################################################
when 'print'

  def print_title(title, underline)
    puts ''
    puts title
    puts underline*title.length
  end

  max_dataset_name_length = dataset_hash
    .select{ |k,v| v[:cook] == 'latest' }
    .map{ |k,v| k.length }
    .max

  case opts[:print][:mode]
  when 'defects'
    defect_defs.sort{ |a,b| a['bit_number'] <=> b['bit_number'] }.each do |defect_def|
      if opts[:print][:porcelain]
        puts defect_def['bit_number']
      else
        puts "#{defect_def['bit_number'].to_s.rjust 5}  #{defect_def['bit_name']}"
      end
    end

  when 'list'
    dataset_hash.each do |dataset_name, dataset|
      if opts[:print][:porcelain]
        puts dataset_name
      else
        if dataset[:cook] == 'latest'
          puts "#{dataset_name.ljust max_dataset_name_length}  ->  refers to #{dataset[:refers_to]}/#{dataset_name}"
        else
          puts dataset_name
        end
      end
    end

  when 'verbose'
    $stderr.puts "WARNING: '--porcelain' option ignored" if opts[:print][:porcelain]
    print_title "#{opts[:print][:run_group].nil? ? 'All' : "Run Group #{opts[:print][:run_group].upcase}"} Datasets and Info", '='
    printout = {}
    dataset_hash.values.map{ |v| v[:cook] }.uniq.sort.each do |cook|
      print_title "#{cook} cook", '-'
      dataset_hash.select{ |k,v| v[:cook] == cook }.sort{ |a,b| a.first <=> b.first }.each do |dataset_name, dataset|
        runlist = JSON.load_file(dataset[:qaTree]).keys.map(&:to_i).sort
        puts [
          dataset_name.rjust(30),
          cook == 'latest' ? "refers to #{dataset[:refers_to]} cook" : nil,
          "runs #{runlist.first} to #{runlist.last}",
        ].compact.join '  ::  '
      end
    end

  else
    raise "nothing to print; run '#{ExeName} print' for guidance"
  end


##################################################################################
# charge command
##################################################################################
when 'charge'

  verb = Proc.new do |message|
    puts message if opts[:charge][:verbose]
  end

  # check for conflicting options
  raise "cannot set both '--reject' and '--allow' options" if opts[:charge][:reject_defect].length>0 and opts[:charge][:allow_defect].length>0
  raise "cannot set both '--reject-misc' and '--allow-misc' options" if opts[:charge][:reject_misc].length>0 and opts[:charge][:allow_misc].length>0
  ['json', 'yaml', 'ttree'].each do |s|
    raise "cannot set both '--verbose' and '--#{s}' options" if opts[:charge][:verbose] and opts[:charge][:output]==s
  end


  # check list of datasets
  datasets = []
  if opts[:charge][:datasets].empty?
    datasets = dataset_hash
      .select{ |k,v| v[:cook] == 'latest' }
      .map{ |k,v| k}
  else
    opts[:charge][:datasets].each do |dataset|
      if dataset_hash.has_key? dataset
        datasets << dataset
      else
        $stderr.puts "WARNING: dataset '#{dataset}' does not exist"
      end
    end
  end
  raise "no valid datasets chosen" if datasets.empty?

  # open chargeTrees and qaTrees
  chargeTree = {}
  qaTree     = {}
  def mergeTree(a,b,name)
    a.merge!(b) do
      raise "dataset '#{name}' has run(s) found in another dataset; please make sure all your datasets are unique (e.g., don't pick two cooks for the same data)"
    end
  end
  verb.call "loading QADBs..."
  datasets.each do |dataset_name|
    verb.call "  - #{dataset_name}"
    mergeTree chargeTree, JSON.load_file(dataset_hash[dataset_name][:chargeTree]), dataset_name
    mergeTree qaTree,     JSON.load_file(dataset_hash[dataset_name][:qaTree]),     dataset_name
  end
  verb.call "...done loading QADBs"

  # filter by run number
  runlist = opts[:charge][:runs]
  runlist = qaTree.keys if runlist.empty?

  # calculate charge
  verb.call "calculating charges..."
  out_hash = {}
  runlist.each do |runnum|
    fcCharge  = 0.0
    ufcCharge = 0.0
    unless chargeTree.has_key? runnum
      $stderr.puts "WARNING: run #{runnum} not found in any dataset"
      next
    end
    chargeTree[runnum].each do |binnum, charge_h|
      fcCharge  += charge_h['fcChargeMax']  - charge_h['fcChargeMin']
      ufcCharge += charge_h['ufcChargeMax'] - charge_h['ufcChargeMin']
    end
    out_hash[runnum] = {
      'fcCharge'  => fcCharge,
      'ufcCharge' => ufcCharge,
    }
  end
  verb.call "...done calculating charges"

  # print output
  raise 'no charge information found for these criteria' if out_hash.empty?
  case opts[:charge][:output]
  when 'default'
    def row(cols)
      puts cols.map{|it|it.to_s.ljust 25}.join(' ')
    end
    row ['run number', 'gated charge', 'ungated charge']
    row ['----------', '------------', '--------------']
    out_hash.each do |runnum, vals|
      row [runnum, vals['fcCharge'].round(5), vals['ufcCharge'].round(5)]
    end
  when 'ttree'
    puts ['runnum/I', 'fc/D', 'ufc/D'].join(':')
    out_hash.each do |runnum, vals|
      puts [runnum, vals['fcCharge'], vals['ufcCharge']].join(' ')
    end
  when 'json'
    puts out_hash.to_json
  when 'yaml'
    puts out_hash.to_yaml
  else
    raise 'unknown output option'
  end

end ### case Command
